What happens when you initialize a repository? Why do you need to do it?

	When you call git init, an invisable folder called .git will be created.
	This file holds all the information needed for git to run.
	It will keep track of things like commits, where the HEAD is, and keep old versions
	 of your files.
	You need to call git init to start using git. Without it you'd just have a folder with 
	 your files.
	To be able to use version control you need git to create and manage all the logic behind it.
	
How is the staging area differnt from the working directory and the repository? What value do you
 think it offers?

	The staging area is a temporary 'in between' area.
	The working directory contains all the current files.
	The repository contains the commits of different versions.
	The staging area allows the user to manipulate what files get added to the repository.
	Using the staging area, you can add or potentionally remove files to add to the repository one
	 by one.
	Once you are done you can commit them to the repository.
	By not automatically adding every new file to a repository on commit, you get the ability to 
	 exclude certain files. For example, large media files or other unwanted files.
	By working with a staging area you can determine what files get commited in a more convenient
	 way.
	If you'd have to add every single file in a commit command then you'd get insanely long
	 terminal commands.
	 
How can you use the staging area to make sure you have one commit per logical change?

	You can use the staging area to firstly put in any changes that are a part of the logical
	 change you want to commit.
	You can then call git diff to compare your working directory and your staging area.
	Doing this allows you to see what changes you have made that you are attempting to commit.
	If there are any files that you still want to include in the commit, you can do so.
	Likewise if you find that you are adding files that shouldn't be in this logical commit,
	 then you have the opportunity to remove them from the staging area.
	Finally you can call git diff --staged to check your staging area against your most recent
	 commit.
	This way you can make sure you are actually commiting the changes that you had in mind.